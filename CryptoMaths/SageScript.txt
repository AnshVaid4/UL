mod() #Modulus of 2 numbers
gcd() #HCF/GCD of 2 numbers
factor()  #prime factorization
list(primes()) #gives prime numbers less than n
xgcd() #Extended Euclidian x0, y0 OR multiplicative inverse in CRT u,v
crt([7,11,22],[8,17,25])  #Chinese remainder theorem ([remainder],[moduli])
euler_phi()
is_prime()
EllipticCurve([0,a,0,b,c])

Chinese remainder theorem
#3x=5 mod 8

k=xgcd(3,8)[1]
mod(5*k,8)



#7x=9(17)

k=xgcd(7,17)[1]
mod(9*k,17)



#11x=17(25)

k=xgcd(11,25)[1]
mod(17*k,25)

-----------------------------------------------------

###EEA extended euclidian algorithm
a=987654321
b=123456789 

def eea(a,b):
    try:
        if a%b>=0:
            print(a,'=',a//b,'*',b,'+',a%b)
            eea(b,a%b)
    except:
        exit(0)

if a>b:
    eea(a,b)
else:
    eea(b,a)


-----------------------------------------------------

#### Discrete log mod results and index(a)

a=[]
p=194813
n=2
counter=0
for i in range(1,p):
    a.append((mod(n^i,p), i))
    counter+=1
    if(mod(n^i,p) ==1):
        break

if counter==euler_phi(p):
    print('n= ',n,' is primitive')
else:
    print('n= ',n,' is not primitive')

print('I(a)\t', 'I')
for i in a:
    print(i[0],'\t',i[1])

-----------------------------------------------------

### Elgamel encryption
import random
set_random_seed(22)
p=194813
g=501
k=random_prime(10^6)  #can be any number, whether prime or not

print('p',p)
print('g',g)
print('k',k)

a=mod(g^k,p)  
print('a',mod(g^k,p))  #g and p and a are sent, k is secret key

m=192746       #message smaller than p
r=999999       #random number r
e1=mod(g^r,p)
print('e1',e1)

e2=mod(m*(a^r),p)
print('e2',e2)

e1k=mod(e1^k,p)
print(e1k)
x_gcd=xgcd(int(e1k),p)
inv=mod(x_gcd[1],p)
print('inverse of',int(e1k),' is ',inv)

print('message',mod(inv*e2,p))

---------------------------------------------------

#Quadratic residue

a=58
q=37

def solgrabber(q):
    print()
    for i in range((q-1)/2):
        print(i,mod(i^2,q))

sol=0

if power_mod(a,(q-1)/2,q) == q-1 or power_mod(a,(q-1)/2,q) == -1:
    print(a,"is not a quadratic residue of",q,":",power_mod(a,(q-1)/2,q))
elif power_mod(a,(q-1)/2,q) == 1:
    sol=1
    print(a,"is a quadratic residue of",q,":",power_mod(a,(q-1)/2,q))
        
if sol==1:
    for i in range(((q-1)/2)+1):
        modq=power_mod(i,2,q)
        if modq==a or modq==a%q:
            print('*',end='')
        print((i,modq),end=',')
    
    print()
        
    #solgrabber(q)
   
---------------------------------------------------
    
#Elliptic curve addition of 2 points
E=EllipticCurve([0,17])
print(E)
plot(E)

P=E(-2,3)
Q=E(-1,4)
P+Q

---------------------------------------------------

'''
Deffie hellman key exchange algorithm, which is based on primitive roots concept

Ax: Private key of A
Bx: Private key of B

Ay: Public key of A
By: Public key of B

g is primitive root of prime number p

'''

Ax=84358759
Bx=4653788

g,p=6,61

Ay=g^Ax%p
By=g^Bx%p

'''key that is used for encryption is computed as follows by A and B. This way the key is not even exposed in internet.'''
(power_mod(By,Ax,p),power_mod(Ay,Bx,p))

---------------------------------------------------

#Finding all points on modulo elliptic curve

p=5
E=EllipticCurve(GF(p),[0,-3,0,3,0])
for i in range(0,p):
    for j in range(0,p):
        try:
            E(i,j)
            print('(',i,j,')')
        except:
            continue

---------------------------------------------------

#Finding Np and ap(p defect) for elliptic curve equations

p=5
equation=[[0,0,0,2,0],[0,0,0,4,2],[0,0,0,1,0],[0,0,0,3,2],[0,0,0,0,1],[0,0,0,2,1],[0,0,0,4,0],[0,0,0,1,1],[0,0,0,3,0]]
for i in equation:
    print(GF(p),EllipticCurve(i))
    print('N5',1+5-(2*sqrt(5).n()),'< N5 <',1+5+(2*sqrt(5).n()))
    
    sum=0
    legendre=[]
    for j in range(0,p):
        x=0
        if i[1] !=0:
            x+=i[1]*j**2
        if i[3] !=0:
            x+=i[3]*j
        if i[4] !=0:
            x+=i[4]
        x+=j**3%p
        legendre.append((x,legendre_symbol(x,p)))
        sum+=legendre_symbol(x,p)
    print('(x, legendreSymbol):',legendre)
    print('n5:',sum+1+p)
    print('p-defect:',1+p-(sum+1+p))

    print('------------------\n')

---------------------------------------------------
