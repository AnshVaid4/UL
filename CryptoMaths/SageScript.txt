mod() #Modulus of 2 numbers
gcd() #HCF/GCD of 2 numbers
factor()  #prime factorization
list(primes()) #gives prime numbers less than n
xgcd() #Extended Euclidian x0, y0 OR multiplicative inverse in CRT u,v
crt([7,11,22],[8,17,25])  #Chinese remainder theorem ([remainder],[moduli])
euler_phi()
is_prime()
EllipticCurve()

Chinese remainder theorem
#3x=5 mod 8

k=xgcd(3,8)[1]
mod(5*k,8)



#7x=9(17)

k=xgcd(7,17)[1]
mod(9*k,17)



#11x=17(25)

k=xgcd(11,25)[1]
mod(17*k,25)

-----------------------------------------------------

###EEA extended euclidian algorithm
a=987654321
b=123456789 

def eea(a,b):
    try:
        if a%b>=0:
            print(a,'=',a//b,'*',b,'+',a%b)
            eea(b,a%b)
    except:
        exit(0)

if a>b:
    eea(a,b)
else:
    eea(b,a)


-----------------------------------------------------

#### Discrete log mod results and index(a)

a=[]
p=194813
n=2
counter=0
for i in range(1,p):
    a.append((mod(n^i,p), i))
    counter+=1
    if(mod(n^i,p) ==1):
        break

if counter==euler_phi(p):
    print('n= ',n,' is primitive')
else:
    print('n= ',n,' is not primitive')

print('I(a)\t', 'I')
for i in a:
    print(i[0],'\t',i[1])

-----------------------------------------------------

### Elgamel encryption
import random
set_random_seed(22)
p=194813
g=501
k=random_prime(10^6)  #can be any number, whether prime or not

print('p',p)
print('g',g)
print('k',k)

a=mod(g^k,p)  
print('a',mod(g^k,p))  #g and p are sent, k is secret key

m=192746       #message smaller than p
r=999999       #random number r
e1=mod(g^r,p)
print('e1',e1)

e2=mod(m*(a^r),p)
print('e2',e2)

e1k=mod(e1^k,p)
print(e1k)
x_gcd=xgcd(int(e1k),p)
inv=mod(x_gcd[1],p)
print('inverse of',int(e1k),' is ',inv)

print('message',mod(inv*e2,p))

---------------------------------------------------

#Quadratic residue

a=58
q=37

def solgrabber(q):
    print()
    for i in range((q-1)/2):
        print(i,mod(i^2,q))

sol=0

if power_mod(a,(q-1)/2,q) == q-1 or power_mod(a,(q-1)/2,q) == -1:
    print(a,"is not a quadratic residue of",q,":",power_mod(a,(q-1)/2,q))
elif power_mod(a,(q-1)/2,q) == 1:
    sol=1
    print(a,"is a quadratic residue of",q,":",power_mod(a,(q-1)/2,q))
        
if sol==1:
    for i in range(((q-1)/2)+1):
        modq=power_mod(i,2,q)
        if modq==a or modq==a%q:
            print('*',end='')
        print((i,modq),end=',')
    
    print()
        
    #solgrabber(q)
   
---------------------------------------------------
    
#Elliptic curve addition of 2 points
E=EllipticCurve([0,17])
print(E)
plot(E)

P=E(-2,3)
Q=E(-1,4)
P+Q

---------------------------------------------------

#Deffie Hellman key exchange

PRI_A=15
PUB_A=power_mod(11,PRI_A,73)

PRI_B=18
PUB_B=power_mod(11,PRI_B,73)

print('public keys shared by A & B respectively: ',PUB_A,PUB_B)

SEC_A=power_mod(PUB_B,PRI_A,73)
SEC_B=power_mod(PUB_A,PRI_B,73)

print('shared key computed: ',SEC_A,SEC_B)

'''
OUTPUT: public keys shared by A & B respectively:  7 46
shared key computed:  27 27
'''

---------------------------------------------------
